from typing import Tuple, Callable

import numpy as np


# --- Generate quadratic function: f(x) = x^T A x ---
def generate_quadratic_form(matrix: np.ndarray) -> Tuple[Callable[[np.ndarray], float], np.ndarray]:
    """
    Generates a quadratic function f(x) = x^T A x based on a given matrix A.

    :param matrix: A symmetric 2x2 matrix.
    :return: (function f(x), matrix A)
    """

    def f(x: np.ndarray) -> float:
        return float(x.T @ matrix @ x)

    # Attach the matrix to the function as an attribute.
    f.matrix = matrix
    return f, matrix


# --- Retrieve matrix from f (attached via generate_quadratic_form) ---
def get_matrix(f: Callable[[np.ndarray], float]) -> np.ndarray:
    """
    Extracts the matrix A from a function f generated by generate_quadratic_form.

    :param f: The function f(x) with an attached .matrix attribute.
    :return: The matrix A.
    """
    if not hasattr(f, 'matrix'):
        raise AttributeError("Function has no matrix attribute. Use generate_quadratic_form.")
    return f.matrix


# --- Evaluate analytic gradient for f(x) = x^T A x ---
# def evaluate_gradient(x: np.ndarray, matrix: np.ndarray) -> np.ndarray:
#     """
#     Returns the analytic gradient of f(x) = x^T A x.
#
#     :param x: The point (np.ndarray)
#     :param matrix: The symmetric matrix A.
#     :return: The gradient vector âˆ‡f(x) = 2Ax.
#     """
#     return 2 * matrix @ x


def evaluate_gradient(x: np.ndarray, f: Callable[[np.ndarray], float]):
    h = 1e-9
    # print(x[:,np.newaxis], np.eye(2))
    l = f(x[:, np.newaxis] + h * np.eye(x.size))
    r = f(x[:, np.newaxis] - h * np.eye(x.size));
    return (l - r) / (2 * h)


# --- Compute condition number ---
def compute_condition_number(matrix: np.ndarray, p: int = 2) -> float:
    """
    Computes the condition number of matrix A using norm p (default is 2-norm).

    :param matrix: The matrix A.
    :param p: Norm type.
    :return: The condition number cond(A).
    """
    return np.linalg.cond(matrix, p=p)
